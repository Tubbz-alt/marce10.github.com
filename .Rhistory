theme(plot.background = element_rect(size = 6, linetype = "solid",
color = cols[i]))
# return(plot_list) # if included, the plots are not grobs!
})
# dev.off()
plot_list
# to create spectrograms in a list, first initialize arguments
X <- Phae.hisnr[!duplicated(Phae.hisnr$sound.files), ] # choosing first song per recording
lapply(LETTERS[1:4], function(x)
as.character(unique(lbhMDS$rid[which(lbhMDS$song.type == x)])))
# creating spectrograms with colored borders by cluster
# make sure to use wav files at 44100 kHz for better spectrogram resolution
plot_list <- lapply(1:nrow(X), function(i) {
ggspectro(tuneR::readWave(as.character(X$sound.files[i]), from = X$start[i] - 0.05,
to = X$end[i] + 0.05, units = "seconds"), f = 22050, wl = 150,
ovlp = 90, palette = reverse.gray.colors.2,
collab = "black", flim = c(1.5, 12), tlab = "",
flab = "", alab = "", scale = FALSE, grid = FALSE,
cexlab = 1.5, trel = FALSE) +
stat_contour(geom = "polygon", aes(fill=..level..), bins = 30) +
scale_fill_continuous(name = "Amplitude (dB)", limits = c(-30,0),
na.value = "transparent", low = "white", high = "black") +
theme_bw() +
guides(color = FALSE, fill = FALSE) +
ggtitle(unique(X$rid)[i]) +
theme(axis.title.x = element_blank(), axis.title.y = element_blank(),
axis.text.x = element_text(size = 20), axis.text.y = element_text(size = 20),
axis.line.x = element_line(size = 20), axis.line.y = element_line(size = 20),
plot.margin = unit(c(2,2,1,1), "lines"),
plot.title = element_text(size = 24, vjust = 1, face = "bold")) +
scale_x_continuous(breaks = c(seq(0,  X$end[i] - X$start[i], 0.1))) +
theme(plot.background = element_rect(size = 6, linetype = "solid",
color = cols[i]))
# return(plot_list) # if included, the plots are not grobs!
})
# dev.off()
plot_list
# to create spectrograms in a list, first initialize arguments
X <- Phae.hisnr[!duplicated(Phae.hisnr$sound.files), ] # choosing first song per recording
lapply(LETTERS[1:4], function(x)
as.character(unique(lbhMDS$rid[which(lbhMDS$song.type == x)])))
# creating spectrograms with colored borders by cluster
# make sure to use wav files at 44100 kHz for better spectrogram resolution
plot_list <- lapply(1:nrow(X), function(i) {
spec <- ggspectro(tuneR::readWave(as.character(X$sound.files[i]), from = X$start[i] - 0.05,
to = X$end[i] + 0.05, units = "seconds"), f = 22050, wl = 150,
ovlp = 90, palette = reverse.gray.colors.2,
collab = "black", flim = c(1.5, 12), tlab = "",
flab = "", alab = "", scale = FALSE, grid = FALSE,
cexlab = 1.5, trel = FALSE) +
stat_contour(geom = "polygon", aes(fill=..level..), bins = 30) +
scale_fill_continuous(name = "Amplitude (dB)", limits = c(-30,0),
na.value = "transparent", low = "white", high = "black") +
theme_bw() +
guides(color = FALSE, fill = FALSE) +
ggtitle(unique(X$rid)[i]) +
theme(axis.title.x = element_blank(), axis.title.y = element_blank(),
axis.text.x = element_text(size = 20), axis.text.y = element_text(size = 20),
axis.line.x = element_line(size = 20), axis.line.y = element_line(size = 20),
plot.margin = unit(c(2,2,1,1), "lines"),
plot.title = element_text(size = 24, vjust = 1, face = "bold")) +
scale_x_continuous(breaks = c(seq(0,  X$end[i] - X$start[i], 0.1))) +
theme(plot.background = element_rect(size = 6, linetype = "solid",
color = cols[i]))
# return(plot_list) # if included, the plots are not grobs!
})
# dev.off()
plot_list
# to create spectrograms in a list, first initialize arguments
X <- Phae.hisnr[!duplicated(Phae.hisnr$sound.files), ] # choosing first song per recording
lapply(LETTERS[1:4], function(x)
as.character(unique(lbhMDS$rid[which(lbhMDS$song.type == x)])))
# creating spectrograms with colored borders by cluster
# make sure to use wav files at 44100 kHz for better spectrogram resolution
plot_list <- lapply(1:nrow(X), function(i) {
spc <- ggspectro(tuneR::readWave(as.character(X$sound.files[i]), from = X$start[i] - 0.05,
to = X$end[i] + 0.05, units = "seconds"), f = 22050, wl = 150,
ovlp = 90, palette = reverse.gray.colors.2,
collab = "black", flim = c(1.5, 12), tlab = "",
flab = "", alab = "", scale = FALSE, grid = FALSE,
cexlab = 1.5, trel = FALSE) +
stat_contour(geom = "polygon", aes(fill=..level..), bins = 30) +
scale_fill_continuous(name = "Amplitude (dB)", limits = c(-30,0),
na.value = "transparent", low = "white", high = "black") +
theme_bw() +
guides(color = FALSE, fill = FALSE) +
ggtitle(unique(X$rid)[i]) +
theme(axis.title.x = element_blank(), axis.title.y = element_blank(),
axis.text.x = element_text(size = 20), axis.text.y = element_text(size = 20),
axis.line.x = element_line(size = 20), axis.line.y = element_line(size = 20),
plot.margin = unit(c(2,2,1,1), "lines"),
plot.title = element_text(size = 24, vjust = 1, face = "bold")) +
scale_x_continuous(breaks = c(seq(0,  X$end[i] - X$start[i], 0.1))) +
theme(plot.background = element_rect(size = 6, linetype = "solid",
color = cols[i]))
return(spc)
# return(plot_list) # if included, the plots are not grobs!
})
# dev.off()
plot_list
lapply(LETTERS[1:4], function(x)
as.character(unique(lbhMDS$rid[which(lbhMDS$song.type == x)])))
# to create spectrograms in a list, first initialize arguments
X <- Phae.hisnr[!duplicated(Phae.hisnr$sound.files), ] # choosing first song per recording
# creating spectrograms with colored borders by cluster
# make sure to use wav files at 44100 kHz for better spectrogram resolution
plot_list <- lapply(1:nrow(X), function(i) {
spc <- ggspectro(tuneR::readWave(as.character(X$sound.files[i]), from = X$start[i] - 0.05,
to = X$end[i] + 0.05, units = "seconds"), f = 22050, wl = 150,
ovlp = 90, palette = reverse.gray.colors.2,
collab = "black", flim = c(1.5, 12), tlab = "",
flab = "", alab = "", scale = FALSE, grid = FALSE,
cexlab = 1.5, trel = FALSE) +
stat_contour(geom = "polygon", aes(fill=..level..), bins = 30) +
scale_fill_continuous(name = "Amplitude (dB)", limits = c(-30,0),
na.value = "transparent", low = "white", high = "black") +
theme_bw() +
guides(color = FALSE, fill = FALSE) +
ggtitle(unique(X$rid)[i]) +
theme(axis.title.x = element_blank(), axis.title.y = element_blank(),
axis.text.x = element_text(size = 20), axis.text.y = element_text(size = 20),
axis.line.x = element_line(size = 20), axis.line.y = element_line(size = 20),
plot.margin = unit(c(2,2,1,1), "lines"),
plot.title = element_text(size = 24, vjust = 1, face = "bold")) +
scale_x_continuous(breaks = c(seq(0,  X$end[i] - X$start[i], 0.1))) +
theme(plot.background = element_rect(size = 6, linetype = "solid",
color = cols[i]))
return(spc)
# return(plot_list) # if included, the plots are not grobs!
})
# dev.off()
plot_list
col.leg <- gtable_filter(ggplot_gtable(ggplot_build(col.leg)), "guide-box")
shape.leg <- gtable_filter(ggplot_gtable(ggplot_build(shape.leg)), "guide-box")
# each component of the figure is a grob or graphical object that can be placed in a viewport
grobs <- list(ggplotGrob(p.mds), col.leg, shape.leg,
ggplotGrob(plot_list[[2]]),
ggplotGrob(plot_list[[4]]),
ggplotGrob(plot_list[[3]]),
ggplotGrob(plot_list[[1]]),
ggplotGrob(plot_list[[6]]),
ggplotGrob(plot_list[[5]]))
sw <- 0.46
sh <- 0.28
buf <- 0.05
sx <- c(0.15-buf, 0.15+ sw)
sy <- c(0.32, 0.62, 0.92)
sxs <- unit.c(unit(sx, "npc"))
sys <- unit.c(unit(sy, "npc"))
sheight <- unit.c(unit(sh, "npc"))
swidth <- unit.c(unit(sw, "npc"))
# the overarching tree has a list of viewports with some stacked on top of each other
# this layout allows for more complex arrangements when creating figures
# but tends to work best when most of grobs are of similar and regular sizes
tree <- vpTree(viewport(w=1, h=1, name="A"),
vpList(viewport(x=0, y = 0.45, w=0.5, h=0.95-buf,
just="left", name="B"),
viewport(x=0.5, y = 0.92, w=0.3, h=buf,
just="center", name="C", angle = 0),
viewport(x=0.5, y = 0.97, w=0.3, h=buf,
just="center", name="D", angle = 0),
vpStack(viewport(x = 0.5, y = 0.95, w = 0.45, h = 0.9,
just=c("left", "top"), name="E"),
vpList(viewport(x = sxs[1], y = sys[1], w = swidth,
h = sheight,
just=c("left", "top"), name="F"),
viewport(x = sxs[1], y = sys[2], w = swidth,
h = sheight,
just=c("left", "top"), name="G"),
viewport(x = sxs[1], y = sys[3], w = swidth,
h = sheight,
just=c("left", "top"), name="H"),
viewport(x = sxs[2], y = sys[1], w = swidth,
h = sheight,
just=c("left", "top"), name="I"),
viewport(x = sxs[2], y = sys[2], w = swidth,
h = sheight,
just=c("left", "top"), name="J"),
viewport(x = sxs[2], y = sys[3], w = swidth,
h = sheight,
just=c("left", "top"), name="K")))))
# png("LBH_dtfs_spectros.png", units = "cm", height = 40, width = 50, res = 300)
grid.newpage()
pushViewport(tree)
vps <- LETTERS[c(2:4, 6:11)]
for(i in 1:length(vps)) {
seekViewport(vps[i])
# viewports are named with letters
# uncomment to visualize overall viewport layout
# grid.rect()
# grid.text(current.vpTree(FALSE),
#           x=unit(1, "mm"), y=unit(1, "npc") - unit(1, "mm"),
#           just=c("left", "top"),
#           gp=gpar(fontsize=8))
grid.draw(grobs[[i]])
}
# A is the whole screen, containing a list from B onwards
# B will hold the MDS plot
# C and D will hold the legends
# E will remain emtpy until nearly the last minute (general spectrogram axes will be drawn)
# F through K will hold the 6 spectrograms
# draw x and y axes for all spectrograms
seekViewport("E")
grid.draw(linesGrob(x = unit(0.05, "npc"), y = c(0, 0.93),
gp=gpar(lwd = 8)))
grid.draw(linesGrob(x = c(0.05, 1.05), y = unit(0, "npc"),
gp=gpar(lwd = 8)))
grid.text("Time (s)", x = 0.5, y = -0.025, rot = 0, gp = gpar(cex = 2.5))
grid.text("Frequency (kHz)", x = 0, y = 0.5, rot = 90, gp = gpar(cex = 2.5))
# dev.off()
lbhMDS
lbhMDS$cols <- lbhMDS$song.type <- lbhMDS$rid
lbhMDS$cols[grep("154070|154072", lbhMDS$rid)]  <-  topo.colors(10)[3]
# extract recording IDs from file names
lbhMDS <- as.data.frame(lbhMDS)
lbhMDS$rid <- gsub( ".wav","", sapply(strsplit(as.character(Phae.hisnr$sound.files), "-",fixed=T), "[",3))
# categorize song types
# note that this step requires visual classification of songs beforehand
# see warbleR::lspec for creating spectrograms of long recordings or warbleR::specreator for creating spectrograms of individual signals
# song type information can also be saved when selecting signals in warbleR::manualoc, using argument selcomm or reccomm arguments
# song is stereotyped in this species, so song type can be determined by looking at a single spectrogram per recording
# create a vector of song type classifications
lbhMDS$cols <- lbhMDS$song.type <- lbhMDS$rid
lbhMDS$song.type[grep("154070|154072", lbhMDS$rid)]  <-  "A"
lbhMDS$cols[grep("154070|154072", lbhMDS$rid)]  <-  topo.colors(10)[3]
lbhMDS$song.type[grep("154123", lbhMDS$rid)]  <-  "B"
lbhMDS$cols[grep("154123", lbhMDS$rid)]  <-  heat.colors(10)[1]
lbhMDS$song.type[grep("154129|154161", lbhMDS$rid)]  <-  "C"
lbhMDS$cols[grep("154129|154161", lbhMDS$rid)]  <- terrain.colors(10)[2]
lbhMDS$song.type[grep("154138", lbhMDS$rid)]  <-  "D"
lbhMDS$cols[grep("154138", lbhMDS$rid)]  <-  heat.colors(10)[6]
p.mds <- ggplot(lbhMDS) + geom_point(aes(x = V1, y = V2, color = song.type,
fill = song.type,
shape = rid), size = 7) +
scale_colour_manual(values = cols) + scale_fill_manual(values = fill.cols) +
scale_shape_manual(values = shps) +
stat_ellipse(aes(x = V1, y = V2, fill = song.type),
geom = "polygon", level = 0.95, alpha = 0.2) +
guides(color = FALSE, shape = FALSE, fill = FALSE) +
xlab("Dimension 1") + ylab("Dimension 2") +
theme(panel.background = element_rect(fill = "white"), plot.background = element_rect(fill = "white"),
panel.grid.major = element_line(size = 1, colour = "grey"),
panel.grid.minor = element_line(size = 0.75, colour = "grey"),
axis.line = element_line(size = 2.5, colour = "black"),
axis.title = element_text(size = 27),
axis.text = element_text(size = 27))
p.mds
p.mds <- ggplot(lbhMDS) + geom_point(aes(x = V1, y = V2, color = song.type,
fill = song.type,
shape = rid), size = 7) +
scale_colour_manual(values = lbhMDS$cols) + scale_fill_manual(values = lbhMDS$cols) +
scale_shape_manual(values = shps) +
stat_ellipse(aes(x = V1, y = V2, fill = song.type),
geom = "polygon", level = 0.95, alpha = 0.2) +
guides(color = FALSE, shape = FALSE, fill = FALSE) +
xlab("Dimension 1") + ylab("Dimension 2") +
theme(panel.background = element_rect(fill = "white"), plot.background = element_rect(fill = "white"),
panel.grid.major = element_line(size = 1, colour = "grey"),
panel.grid.minor = element_line(size = 0.75, colour = "grey"),
axis.line = element_line(size = 2.5, colour = "black"),
axis.title = element_text(size = 27),
axis.text = element_text(size = 27))
p.mds
p.mds <- ggplot(lbhMDS) + geom_point(aes(x = V1, y = V2, color = song.type,
fill = song.type,
shape = rid), size = 7) +
scale_colour_manual(values = cols) + scale_fill_manual(values = cols) +
scale_shape_manual(values = shps) +
stat_ellipse(aes(x = V1, y = V2, fill = song.type),
geom = "polygon", level = 0.95, alpha = 0.2) +
guides(color = FALSE, shape = FALSE, fill = FALSE) +
xlab("Dimension 1") + ylab("Dimension 2") +
theme(panel.background = element_rect(fill = "white"), plot.background = element_rect(fill = "white"),
panel.grid.major = element_line(size = 1, colour = "grey"),
panel.grid.minor = element_line(size = 0.75, colour = "grey"),
axis.line = element_line(size = 2.5, colour = "black"),
axis.title = element_text(size = 27),
axis.text = element_text(size = 27))
p.mds
col.leg <- p.mds + guides(color = guide_legend("Song Type", nrow = 1, byrow = TRUE),
shape = FALSE, size = FALSE) +
theme(legend.box = "horizontal", legend.position = "top",
legend.key.size = unit(1, "cm"), legend.title = element_text(size = 30),
legend.text = element_text(size = 30),
legend.background = element_rect(fill = alpha("white", 0.4)),
legend.key = element_rect(fill = alpha("white", 0.4)))
shape.leg <- p.mds + guides(color = FALSE,
shape = guide_legend("Recordings", nrow = 1, byrow = TRUE), size = FALSE) +
theme(legend.box = "horizontal", legend.position = "top",
legend.key.size = unit(1, "cm"), legend.title = element_text(size = 27),
legend.text = element_text(size = 27),
legend.background = element_rect(fill = alpha("white", 0.4)),
legend.key = element_rect(fill = alpha("white", 0.4)))
col.leg
col.leg <- p.mds + guides(color = guide_legend("Song Type", nrow = 1, byrow = TRUE),
shape = FALSE, size = FALSE) +
theme(legend.box = "horizontal", legend.position = "top",
legend.key.size = unit(1, "cm"), legend.title = element_text(size = 30),
legend.text = element_text(size = 30),
legend.background = element_rect(fill = alpha("white", 0.4)),
legend.key = element_rect(fill = alpha("white", 0.4)))
shape.leg <- p.mds + guides(color = FALSE,
shape = guide_legend("Recordings", nrow = 1, byrow = TRUE), size = FALSE) +
theme(legend.box = "horizontal", legend.position = "top",
legend.key.size = unit(1, "cm"), legend.title = element_text(size = 27),
legend.text = element_text(size = 27),
legend.background = element_rect(fill = alpha("white", 0.4)),
legend.key = element_rect(fill = alpha("white", 0.4)))
col.leg
X <- lbhMDS$cols[!duplicated(Phae.hisnr$sound.files), ]
X$cols <- lbhMDS$cols[!duplicated(Phae.hisnr$sound.files), ]
X <- Phae.hisnr[!duplicated(Phae.hisnr$sound.files), ] # choosing first song per recording
X$cols <- lbhMDS$cols[!duplicated(Phae.hisnr$sound.files), ]
lbhMDS$cols
X <- Phae.hisnr[!duplicated(Phae.hisnr$sound.files), ] # choosing first song per recording
X$cols <- lbhMDS$cols[!duplicated(X$sound.files), ]
X <- Phae.hisnr[!duplicated(Phae.hisnr$sound.files), ] # choosing first song per recording
X$cols <- lbhMDS$cols[!duplicated(Phae.hisnr$sound.files)]
# to create spectrograms in a list, first initialize arguments
X <- Phae.hisnr[!duplicated(Phae.hisnr$sound.files), ] # choosing first song per recording
X$cols <- lbhMDS$cols[!duplicated(Phae.hisnr$sound.files)]
# creating spectrograms with colored borders by cluster
# make sure to use wav files at 44100 kHz for better spectrogram resolution
plot_list <- lapply(1:nrow(X), function(i) {
spc <- ggspectro(tuneR::readWave(as.character(X$sound.files[i]), from = X$start[i] - 0.05,
to = X$end[i] + 0.05, units = "seconds"), f = 22050, wl = 150,
ovlp = 90, palette = reverse.gray.colors.2,
collab = "black", flim = c(1.5, 12), tlab = "",
flab = "", alab = "", scale = FALSE, grid = FALSE,
cexlab = 1.5, trel = FALSE) +
stat_contour(geom = "polygon", aes(fill=..level..), bins = 30) +
scale_fill_continuous(name = "Amplitude (dB)", limits = c(-30,0),
na.value = "transparent", low = "white", high = "black") +
theme_bw() +
guides(color = FALSE, fill = FALSE) +
ggtitle(unique(X$rid)[i]) +
theme(axis.title.x = element_blank(), axis.title.y = element_blank(),
axis.text.x = element_text(size = 20), axis.text.y = element_text(size = 20),
axis.line.x = element_line(size = 20), axis.line.y = element_line(size = 20),
plot.margin = unit(c(2,2,1,1), "lines"),
plot.title = element_text(size = 24, vjust = 1, face = "bold")) +
scale_x_continuous(breaks = c(seq(0,  X$end[i] - X$start[i], 0.1))) +
theme(plot.background = element_rect(size = 6, linetype = "solid",
color = X$cols[i]))
return(spc)
# return(plot_list) # if included, the plots are not grobs!
})
# dev.off()
plot_list
col.leg <- gtable_filter(ggplot_gtable(ggplot_build(col.leg)), "guide-box")
shape.leg <- gtable_filter(ggplot_gtable(ggplot_build(shape.leg)), "guide-box")
# each component of the figure is a grob or graphical object that can be placed in a viewport
grobs <- list(ggplotGrob(p.mds), col.leg, shape.leg,
ggplotGrob(plot_list[[2]]),
ggplotGrob(plot_list[[4]]),
ggplotGrob(plot_list[[3]]),
ggplotGrob(plot_list[[1]]),
ggplotGrob(plot_list[[6]]),
ggplotGrob(plot_list[[5]]))
sw <- 0.46
sh <- 0.28
buf <- 0.05
sx <- c(0.15-buf, 0.15+ sw)
sy <- c(0.32, 0.62, 0.92)
sxs <- unit.c(unit(sx, "npc"))
sys <- unit.c(unit(sy, "npc"))
sheight <- unit.c(unit(sh, "npc"))
swidth <- unit.c(unit(sw, "npc"))
# the overarching tree has a list of viewports with some stacked on top of each other
# this layout allows for more complex arrangements when creating figures
# but tends to work best when most of grobs are of similar and regular sizes
tree <- vpTree(viewport(w=1, h=1, name="A"),
vpList(viewport(x=0, y = 0.45, w=0.5, h=0.95-buf,
just="left", name="B"),
viewport(x=0.5, y = 0.92, w=0.3, h=buf,
just="center", name="C", angle = 0),
viewport(x=0.5, y = 0.97, w=0.3, h=buf,
just="center", name="D", angle = 0),
vpStack(viewport(x = 0.5, y = 0.95, w = 0.45, h = 0.9,
just=c("left", "top"), name="E"),
vpList(viewport(x = sxs[1], y = sys[1], w = swidth,
h = sheight,
just=c("left", "top"), name="F"),
viewport(x = sxs[1], y = sys[2], w = swidth,
h = sheight,
just=c("left", "top"), name="G"),
viewport(x = sxs[1], y = sys[3], w = swidth,
h = sheight,
just=c("left", "top"), name="H"),
viewport(x = sxs[2], y = sys[1], w = swidth,
h = sheight,
just=c("left", "top"), name="I"),
viewport(x = sxs[2], y = sys[2], w = swidth,
h = sheight,
just=c("left", "top"), name="J"),
viewport(x = sxs[2], y = sys[3], w = swidth,
h = sheight,
just=c("left", "top"), name="K")))))
# png("LBH_dtfs_spectros.png", units = "cm", height = 40, width = 50, res = 300)
grid.newpage()
pushViewport(tree)
vps <- LETTERS[c(2:4, 6:11)]
for(i in 1:length(vps)) {
seekViewport(vps[i])
# viewports are named with letters
# uncomment to visualize overall viewport layout
# grid.rect()
# grid.text(current.vpTree(FALSE),
#           x=unit(1, "mm"), y=unit(1, "npc") - unit(1, "mm"),
#           just=c("left", "top"),
#           gp=gpar(fontsize=8))
grid.draw(grobs[[i]])
}
# A is the whole screen, containing a list from B onwards
# B will hold the MDS plot
# C and D will hold the legends
# E will remain emtpy until nearly the last minute (general spectrogram axes will be drawn)
# F through K will hold the 6 spectrograms
# draw x and y axes for all spectrograms
seekViewport("E")
grid.draw(linesGrob(x = unit(0.05, "npc"), y = c(0, 0.93),
gp=gpar(lwd = 8)))
grid.draw(linesGrob(x = c(0.05, 1.05), y = unit(0, "npc"),
gp=gpar(lwd = 8)))
grid.text("Time (s)", x = 0.5, y = -0.025, rot = 0, gp = gpar(cex = 2.5))
grid.text("Frequency (kHz)", x = 0, y = 0.5, rot = 90, gp = gpar(cex = 2.5))
# dev.off()
col.leg <- gtable_filter(ggplot_gtable(ggplot_build(col.leg)), "guide-box")
shape.leg <- gtable_filter(ggplot_gtable(ggplot_build(shape.leg)), "guide-box")
grobs <- list(ggplotGrob(p.mds), col.leg, shape.leg,
ggplotGrob(plot_list[[2]]),
ggplotGrob(plot_list[[4]]),
ggplotGrob(plot_list[[3]]),
ggplotGrob(plot_list[[1]]),
ggplotGrob(plot_list[[6]]),
ggplotGrob(plot_list[[5]]))
grobs
sw <- 0.46
sh <- 0.28
buf <- 0.05
sx <- c(0.15-buf, 0.15+ sw)
sy <- c(0.32, 0.62, 0.92)
sxs <- unit.c(unit(sx, "npc"))
sys <- unit.c(unit(sy, "npc"))
sheight <- unit.c(unit(sh, "npc"))
swidth <- unit.c(unit(sw, "npc"))
tree <- vpTree(viewport(w=1, h=1, name="A"),
vpList(viewport(x=0, y = 0.45, w=0.5, h=0.95-buf,
just="left", name="B"),
viewport(x=0.5, y = 0.92, w=0.3, h=buf,
just="center", name="C", angle = 0),
viewport(x=0.5, y = 0.97, w=0.3, h=buf,
just="center", name="D", angle = 0),
vpStack(viewport(x = 0.5, y = 0.95, w = 0.45, h = 0.9,
just=c("left", "top"), name="E"),
vpList(viewport(x = sxs[1], y = sys[1], w = swidth,
h = sheight,
just=c("left", "top"), name="F"),
viewport(x = sxs[1], y = sys[2], w = swidth,
h = sheight,
just=c("left", "top"), name="G"),
viewport(x = sxs[1], y = sys[3], w = swidth,
h = sheight,
just=c("left", "top"), name="H"),
viewport(x = sxs[2], y = sys[1], w = swidth,
h = sheight,
just=c("left", "top"), name="I"),
viewport(x = sxs[2], y = sys[2], w = swidth,
h = sheight,
just=c("left", "top"), name="J"),
viewport(x = sxs[2], y = sys[3], w = swidth,
h = sheight,
just=c("left", "top"), name="K")))))
grid.newpage()
pushViewport(tree)
vps <- LETTERS[c(2:4, 6:11)]
for(i in 1:length(vps)) {
seekViewport(vps[i])
# viewports are named with letters
# uncomment to visualize overall viewport layout
# grid.rect()
# grid.text(current.vpTree(FALSE),
#           x=unit(1, "mm"), y=unit(1, "npc") - unit(1, "mm"),
#           just=c("left", "top"),
#           gp=gpar(fontsize=8))
grid.draw(grobs[[i]])
}
seekViewport("E")
grid.draw(linesGrob(x = unit(0.05, "npc"), y = c(0, 0.93),
gp=gpar(lwd = 8)))
grid.draw(linesGrob(x = c(0.05, 1.05), y = unit(0, "npc"),
gp=gpar(lwd = 8)))
grid.text("Time (s)", x = 0.5, y = -0.025, rot = 0, gp = gpar(cex = 2.5))
grid.text("Frequency (kHz)", x = 0, y = 0.5, rot = 90, gp = gpar(cex = 2.5))
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
p.mds
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
x <- c("ggplot2", "gtable", "grid", "warbleR")
out <- lapply(x, function(y) {
if(!y %in% installed.packages()[,"Package"])  install.packages(y)
require(y, character.only = T)
})
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
KnitPost(site.path = "~/Dropbox/Websites/Blog/maRce10.github.com/", rmd.file =  "~/Dropbox/Websites/Blog/maRce10.github.com/_Rmd/Acoustic space scatter plot.Rmd", rm.output.text = F)
